/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.15.4.0 (NJsonSchema v9.10.29.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/operator/finally';
import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { Http, Headers, ResponseContentType, Response } from '@angular/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>Observable.throw(response_);
        });
    }

    protected processIsTenantAvailable(response: Response): Observable<IsTenantAvailableOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    register(input: RegisterInput): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processRegister(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<RegisterOutput>><any>Observable.throw(response_);
        });
    }

    protected processRegister(response: Response): Observable<RegisterOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RegisterOutput>(<any>null);
    }
}

@Injectable()
export class CategoryServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<CategoryOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/Category/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CategoryOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<CategoryOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<CategoryOutput[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CategoryOutput.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CategoryOutput[]>(<any>null);
    }

    /**
     * @return Success
     */
    get(id: number): Observable<CategoryOutput> {
        let url_ = this.baseUrl + "/api/services/app/Category/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CategoryOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CategoryOutput>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<CategoryOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategoryOutput.fromJS(resultData200) : new CategoryOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CategoryOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: CategoryCreateInput): Observable<CategoryOutput> {
        let url_ = this.baseUrl + "/api/services/app/Category/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CategoryOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CategoryOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<CategoryOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategoryOutput.fromJS(resultData200) : new CategoryOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<CategoryOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: CategoryUpdateInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Category/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Category/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changeUiTheme(input: ChangeUiThemeInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processChangeUiTheme(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class MobileCategoryServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAll(): Observable<MobileCategoryOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/MobileCategory/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<MobileCategoryOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileCategoryOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<MobileCategoryOutput[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MobileCategoryOutput.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileCategoryOutput[]>(<any>null);
    }
}

@Injectable()
export class MobileOrderServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filter (optional) 
     * @return Success
     */
    getAll(maxResultCount: number, skipCount: number, filter: string): Observable<PagedResultDtoOfMobileOrderOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileOrder/GetAll?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMobileOrderOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfMobileOrderOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfMobileOrderOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfMobileOrderOutput.fromJS(resultData200) : new PagedResultDtoOfMobileOrderOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfMobileOrderOutput>(<any>null);
    }

    /**
     * @return Success
     */
    get(id: number): Observable<MobileOrderOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileOrder/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<MobileOrderOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileOrderOutput>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<MobileOrderOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MobileOrderOutput.fromJS(resultData200) : new MobileOrderOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileOrderOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: MobileOrderCreateInput): Observable<MobileOrderOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileOrder/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<MobileOrderOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileOrderOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<MobileOrderOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MobileOrderOutput.fromJS(resultData200) : new MobileOrderOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileOrderOutput>(<any>null);
    }
}

@Injectable()
export class MobileServiceProviderServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: number): Observable<MobileServiceProviderOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileServiceProvider/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<MobileServiceProviderOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileServiceProviderOutput>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<MobileServiceProviderOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MobileServiceProviderOutput.fromJS(resultData200) : new MobileServiceProviderOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileServiceProviderOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    query(input: MobileServiceProviderListQueryInput): Observable<PagedResultDtoOfMobileServiceProviderListOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileServiceProvider/Query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processQuery(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processQuery(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMobileServiceProviderListOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfMobileServiceProviderListOutput>><any>Observable.throw(response_);
        });
    }

    protected processQuery(response: Response): Observable<PagedResultDtoOfMobileServiceProviderListOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfMobileServiceProviderListOutput.fromJS(resultData200) : new PagedResultDtoOfMobileServiceProviderListOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfMobileServiceProviderListOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getCurrent(): Observable<MobileServiceProviderDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileServiceProvider/GetCurrent";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCurrent(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCurrent(<any>response_);
                } catch (e) {
                    return <Observable<MobileServiceProviderDetailOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileServiceProviderDetailOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetCurrent(response: Response): Observable<MobileServiceProviderDetailOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MobileServiceProviderDetailOutput.fromJS(resultData200) : new MobileServiceProviderDetailOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileServiceProviderDetailOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getPaymentInfo(): Observable<MobileServiceProviderPaymentInfoOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileServiceProvider/GetPaymentInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<MobileServiceProviderPaymentInfoOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileServiceProviderPaymentInfoOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetPaymentInfo(response: Response): Observable<MobileServiceProviderPaymentInfoOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MobileServiceProviderPaymentInfoOutput.fromJS(resultData200) : new MobileServiceProviderPaymentInfoOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileServiceProviderPaymentInfoOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    register(input: MobileServiceProviderRegisterInput): Observable<MobileServiceProviderDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileServiceProvider/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processRegister(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<MobileServiceProviderDetailOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileServiceProviderDetailOutput>><any>Observable.throw(response_);
        });
    }

    protected processRegister(response: Response): Observable<MobileServiceProviderDetailOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MobileServiceProviderDetailOutput.fromJS(resultData200) : new MobileServiceProviderDetailOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileServiceProviderDetailOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    submitRegister(input: EntityDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MobileServiceProvider/SubmitRegister";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSubmitRegister(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSubmitRegister(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSubmitRegister(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: MobileServiceProviderUpdateInput): Observable<MobileServiceProviderDetailOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileServiceProvider/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<MobileServiceProviderDetailOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileServiceProviderDetailOutput>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<MobileServiceProviderDetailOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MobileServiceProviderDetailOutput.fromJS(resultData200) : new MobileServiceProviderDetailOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileServiceProviderDetailOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getAllServiceItems(): Observable<MobileServiceProviderItemOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/MobileServiceProvider/GetAllServiceItems";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAllServiceItems(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAllServiceItems(<any>response_);
                } catch (e) {
                    return <Observable<MobileServiceProviderItemOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileServiceProviderItemOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAllServiceItems(response: Response): Observable<MobileServiceProviderItemOutput[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MobileServiceProviderItemOutput.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileServiceProviderItemOutput[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateServiceItems(input: MobileServiceProviderItemsUpdateInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MobileServiceProvider/UpdateServiceItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateServiceItems(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateServiceItems(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateServiceItems(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @filter (optional) 
     * @return Success
     */
    getOrderList(maxResultCount: number, skipCount: number, filter: string): Observable<PagedResultDtoOfMobileServiceProviderOrderOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileServiceProvider/GetOrderList?";
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetOrderList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetOrderList(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMobileServiceProviderOrderOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfMobileServiceProviderOrderOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetOrderList(response: Response): Observable<PagedResultDtoOfMobileServiceProviderOrderOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfMobileServiceProviderOrderOutput.fromJS(resultData200) : new PagedResultDtoOfMobileServiceProviderOrderOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfMobileServiceProviderOrderOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getOrderDetail(id: number): Observable<MobileServiceProviderOrderOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileServiceProvider/GetOrderDetail?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetOrderDetail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetOrderDetail(<any>response_);
                } catch (e) {
                    return <Observable<MobileServiceProviderOrderOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileServiceProviderOrderOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetOrderDetail(response: Response): Observable<MobileServiceProviderOrderOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MobileServiceProviderOrderOutput.fromJS(resultData200) : new MobileServiceProviderOrderOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileServiceProviderOrderOutput>(<any>null);
    }

    /**
     * @return Success
     */
    acceptOrder(id: number): Observable<MobileServiceProviderOrderOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileServiceProvider/AcceptOrder?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processAcceptOrder(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAcceptOrder(<any>response_);
                } catch (e) {
                    return <Observable<MobileServiceProviderOrderOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileServiceProviderOrderOutput>><any>Observable.throw(response_);
        });
    }

    protected processAcceptOrder(response: Response): Observable<MobileServiceProviderOrderOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MobileServiceProviderOrderOutput.fromJS(resultData200) : new MobileServiceProviderOrderOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileServiceProviderOrderOutput>(<any>null);
    }

    /**
     * @return Success
     */
    cancelOrder(id: number): Observable<MobileServiceProviderOrderOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileServiceProvider/CancelOrder?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCancelOrder(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCancelOrder(<any>response_);
                } catch (e) {
                    return <Observable<MobileServiceProviderOrderOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileServiceProviderOrderOutput>><any>Observable.throw(response_);
        });
    }

    protected processCancelOrder(response: Response): Observable<MobileServiceProviderOrderOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MobileServiceProviderOrderOutput.fromJS(resultData200) : new MobileServiceProviderOrderOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileServiceProviderOrderOutput>(<any>null);
    }

    /**
     * @return Success
     */
    finishOrder(id: number): Observable<MobileServiceProviderOrderOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileServiceProvider/FinishOrder?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processFinishOrder(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processFinishOrder(<any>response_);
                } catch (e) {
                    return <Observable<MobileServiceProviderOrderOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileServiceProviderOrderOutput>><any>Observable.throw(response_);
        });
    }

    protected processFinishOrder(response: Response): Observable<MobileServiceProviderOrderOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MobileServiceProviderOrderOutput.fromJS(resultData200) : new MobileServiceProviderOrderOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileServiceProviderOrderOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getBannerAds(): Observable<BannerAdOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/MobileServiceProvider/GetBannerAds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetBannerAds(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetBannerAds(<any>response_);
                } catch (e) {
                    return <Observable<BannerAdOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<BannerAdOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processGetBannerAds(response: Response): Observable<BannerAdOutput[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(BannerAdOutput.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<BannerAdOutput[]>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPaymentRecords(): Observable<MobileServiceProviderPaymentRecordOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/MobileServiceProvider/GetAllPaymentRecords";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAllPaymentRecords(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAllPaymentRecords(<any>response_);
                } catch (e) {
                    return <Observable<MobileServiceProviderPaymentRecordOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileServiceProviderPaymentRecordOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAllPaymentRecords(response: Response): Observable<MobileServiceProviderPaymentRecordOutput[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MobileServiceProviderPaymentRecordOutput.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileServiceProviderPaymentRecordOutput[]>(<any>null);
    }
}

@Injectable()
export class MobileWechatUserServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUser(): Observable<WechatUserOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileWechatUser/GetCurrentUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCurrentUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCurrentUser(<any>response_);
                } catch (e) {
                    return <Observable<WechatUserOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<WechatUserOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetCurrentUser(response: Response): Observable<WechatUserOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WechatUserOutput.fromJS(resultData200) : new WechatUserOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<WechatUserOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    bindSubscribe(input: MobileBindSubscribeInput): Observable<WechatUserOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileWechatUser/BindSubscribe";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processBindSubscribe(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processBindSubscribe(<any>response_);
                } catch (e) {
                    return <Observable<WechatUserOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<WechatUserOutput>><any>Observable.throw(response_);
        });
    }

    protected processBindSubscribe(response: Response): Observable<WechatUserOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WechatUserOutput.fromJS(resultData200) : new WechatUserOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<WechatUserOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getUserAddress(id: number): Observable<MobileWechatUserAddressOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileWechatUser/GetUserAddress?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetUserAddress(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUserAddress(<any>response_);
                } catch (e) {
                    return <Observable<MobileWechatUserAddressOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileWechatUserAddressOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetUserAddress(response: Response): Observable<MobileWechatUserAddressOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MobileWechatUserAddressOutput.fromJS(resultData200) : new MobileWechatUserAddressOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileWechatUserAddressOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getUserAddressList(): Observable<MobileWechatUserAddressOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/MobileWechatUser/GetUserAddressList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetUserAddressList(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetUserAddressList(<any>response_);
                } catch (e) {
                    return <Observable<MobileWechatUserAddressOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileWechatUserAddressOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processGetUserAddressList(response: Response): Observable<MobileWechatUserAddressOutput[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(MobileWechatUserAddressOutput.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileWechatUserAddressOutput[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateDefaultUserAddress(input: EntityDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MobileWechatUser/UpdateDefaultUserAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateDefaultUserAddress(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateDefaultUserAddress(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateDefaultUserAddress(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    removeUserAddress(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MobileWechatUser/RemoveUserAddress?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processRemoveUserAddress(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processRemoveUserAddress(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processRemoveUserAddress(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    saveWechatUserAddress(input: MobileWechatUserAddressCreateOrUpdateInput): Observable<MobileWechatUserAddressOutput> {
        let url_ = this.baseUrl + "/api/services/app/MobileWechatUser/SaveWechatUserAddress";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processSaveWechatUserAddress(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processSaveWechatUserAddress(<any>response_);
                } catch (e) {
                    return <Observable<MobileWechatUserAddressOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<MobileWechatUserAddressOutput>><any>Observable.throw(response_);
        });
    }

    protected processSaveWechatUserAddress(response: Response): Observable<MobileWechatUserAddressOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MobileWechatUserAddressOutput.fromJS(resultData200) : new MobileWechatUserAddressOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<MobileWechatUserAddressOutput>(<any>null);
    }
}

@Injectable()
export class OrderServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @beginTime (optional) 
     * @endTime (optional) 
     * @serviceProviderId (optional) 
     * @return Success
     */
    getAll(beginTime: moment.Moment, endTime: moment.Moment, serviceProviderId: number, maxResultCount: number, skipCount: number): Observable<PagedResultDtoOfOrderOutput> {
        let url_ = this.baseUrl + "/api/services/app/Order/GetAll?";
        if (beginTime !== undefined)
            url_ += "BeginTime=" + encodeURIComponent(beginTime ? "" + beginTime.toJSON() : "") + "&"; 
        if (endTime !== undefined)
            url_ += "EndTime=" + encodeURIComponent(endTime ? "" + endTime.toJSON() : "") + "&"; 
        if (serviceProviderId !== undefined)
            url_ += "ServiceProviderId=" + encodeURIComponent("" + serviceProviderId) + "&"; 
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrderOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrderOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfOrderOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrderOutput.fromJS(resultData200) : new PagedResultDtoOfOrderOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfOrderOutput>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: CreateRoleDto): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<RoleDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<RoleDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RoleDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: RoleDto): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<RoleDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<RoleDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RoleDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfPermissionDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPermissionDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfPermissionDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAllPermissions(response: Response): Observable<ListResultDtoOfPermissionDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfPermissionDto>(<any>null);
    }

    /**
     * @return Success
     */
    get(id: number): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<RoleDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<RoleDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<RoleDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAll(skipCount: number, maxResultCount: number): Observable<PagedResultDtoOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRoleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfRoleDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfRoleDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRoleDto.fromJS(resultData200) : new PagedResultDtoOfRoleDto();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfRoleDto>(<any>null);
    }
}

@Injectable()
export class ServiceProviderServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(id: number): Observable<ServiceProviderOutput> {
        let url_ = this.baseUrl + "/api/services/app/ServiceProvider/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ServiceProviderOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceProviderOutput>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<ServiceProviderOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceProviderOutput.fromJS(resultData200) : new ServiceProviderOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ServiceProviderOutput>(<any>null);
    }

    /**
     * @categoryId (optional) 
     * @filter (optional) 
     * @return Success
     */
    getAll(categoryId: number, maxResultCount: number, skipCount: number, filter: string): Observable<PagedResultDtoOfServiceProviderListOutput> {
        let url_ = this.baseUrl + "/api/services/app/ServiceProvider/GetAll?";
        if (categoryId !== undefined)
            url_ += "CategoryId=" + encodeURIComponent("" + categoryId) + "&"; 
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfServiceProviderListOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfServiceProviderListOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfServiceProviderListOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfServiceProviderListOutput.fromJS(resultData200) : new PagedResultDtoOfServiceProviderListOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfServiceProviderListOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: ServiceProviderUpdateInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ServiceProvider/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateDisplayState(input: ServiceProviderUpdateDisplayStateInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ServiceProvider/UpdateDisplayState";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateDisplayState(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateDisplayState(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateDisplayState(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateAuditState(input: ServiceProviderUpdateAuditStateInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ServiceProvider/UpdateAuditState";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateAuditState(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateAuditState(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateAuditState(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateCategories(input: ServiceProviderUpdateCategoriesInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ServiceProvider/UpdateCategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateCategories(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateCategories(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateCategories(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateExpirationDate(input: ServiceProviderUpdateExpirationDateInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ServiceProvider/UpdateExpirationDate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateExpirationDate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateExpirationDate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateExpirationDate(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateExpirationPaymentMoney(input: ServiceProviderUpdateExpirationPaymentMoneyInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ServiceProvider/UpdateExpirationPaymentMoney";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateExpirationPaymentMoney(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateExpirationPaymentMoney(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateExpirationPaymentMoney(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllServiceItems(): Observable<ServiceProviderItemOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/ServiceProvider/GetAllServiceItems";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAllServiceItems(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAllServiceItems(<any>response_);
                } catch (e) {
                    return <Observable<ServiceProviderItemOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceProviderItemOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAllServiceItems(response: Response): Observable<ServiceProviderItemOutput[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ServiceProviderItemOutput.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ServiceProviderItemOutput[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createServiceItem(input: ServiceProviderItemCreateInput): Observable<ServiceProviderItemOutput> {
        let url_ = this.baseUrl + "/api/services/app/ServiceProvider/CreateServiceItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateServiceItem(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateServiceItem(<any>response_);
                } catch (e) {
                    return <Observable<ServiceProviderItemOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceProviderItemOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreateServiceItem(response: Response): Observable<ServiceProviderItemOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceProviderItemOutput.fromJS(resultData200) : new ServiceProviderItemOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ServiceProviderItemOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateServiceItem(input: ServiceProviderItemUpdateInput): Observable<ServiceProviderItemOutput> {
        let url_ = this.baseUrl + "/api/services/app/ServiceProvider/UpdateServiceItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdateServiceItem(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdateServiceItem(<any>response_);
                } catch (e) {
                    return <Observable<ServiceProviderItemOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceProviderItemOutput>><any>Observable.throw(response_);
        });
    }

    protected processUpdateServiceItem(response: Response): Observable<ServiceProviderItemOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceProviderItemOutput.fromJS(resultData200) : new ServiceProviderItemOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ServiceProviderItemOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getServiceItem(id: number): Observable<ServiceProviderItemOutput> {
        let url_ = this.baseUrl + "/api/services/app/ServiceProvider/GetServiceItem?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetServiceItem(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetServiceItem(<any>response_);
                } catch (e) {
                    return <Observable<ServiceProviderItemOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<ServiceProviderItemOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetServiceItem(response: Response): Observable<ServiceProviderItemOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ServiceProviderItemOutput.fromJS(resultData200) : new ServiceProviderItemOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ServiceProviderItemOutput>(<any>null);
    }

    /**
     * @return Success
     */
    deleteServiceItem(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ServiceProvider/DeleteServiceItem?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDeleteServiceItem(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDeleteServiceItem(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteServiceItem(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetCurrentLoginInformations(response: Response): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: CreateTenantDto): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TenantDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<TenantDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TenantDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    get(id: number): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TenantDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<TenantDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TenantDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAll(skipCount: number, maxResultCount: number): Observable<PagedResultDtoOfTenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfTenantDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantDto.fromJS(resultData200) : new PagedResultDtoOfTenantDto();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfTenantDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: TenantDto): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TenantDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<TenantDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<TenantDto>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processAuthenticate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>Observable.throw(response_);
        });
    }

    protected processAuthenticate(response: Response): Observable<AuthenticateResultModel> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>Observable.throw(response_);
        });
    }

    protected processGetExternalAuthenticationProviders(response: Response): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>Observable.throw(response_);
        });
    }

    protected processExternalAuthenticate(response: Response): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ExternalAuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: CreateUserDto): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserDto>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: Response): Observable<UserDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: UserDto): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: Response): Observable<UserDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserDto>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "delete",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<ListResultDtoOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetRoles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleDto>><any>Observable.throw(response_);
        });
    }

    protected processGetRoles(response: Response): Observable<ListResultDtoOfRoleDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleDto.fromJS(resultData200) : new ListResultDtoOfRoleDto();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<ListResultDtoOfRoleDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processChangeLanguage(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    get(id: number): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserDto>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<UserDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<UserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAll(skipCount: number, maxResultCount: number): Observable<PagedResultDtoOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (skipCount === undefined || skipCount === null)
            throw new Error("The parameter 'skipCount' must be defined and cannot be null.");
        else
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount === undefined || maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' must be defined and cannot be null.");
        else
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: Response): Observable<PagedResultDtoOfUserDto> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserDto.fromJS(resultData200) : new PagedResultDtoOfUserDto();
            return Observable.of(result200);
        } else if (status === 401) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status === 403) {
            const _responseText = response.text();
            return throwException("A server error occurred.", status, _responseText, _headers);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfUserDto>(<any>null);
    }
}

@Injectable()
export class WeappTokenAuthServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @model (optional) 
     * @return Success
     */
    authenticate(model: WeappAuthenticateModel): Observable<WeappAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/WeappTokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processAuthenticate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<WeappAuthenticateResultModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<WeappAuthenticateResultModel>><any>Observable.throw(response_);
        });
    }

    protected processAuthenticate(response: Response): Observable<WeappAuthenticateResultModel> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WeappAuthenticateResultModel.fromJS(resultData200) : new WeappAuthenticateResultModel();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<WeappAuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class WechatUserServiceProxy {
    private http: Http;
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdate(input: WechatUserCreateOrUpdateInput): Observable<WechatUserOutput> {
        let url_ = this.baseUrl + "/api/services/app/WechatUser/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<WechatUserOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<WechatUserOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrUpdate(response: Response): Observable<WechatUserOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WechatUserOutput.fromJS(resultData200) : new WechatUserOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<WechatUserOutput>(<any>null);
    }

    /**
     * @pagedResultRequest (optional) 
     * @return Success
     */
    query(pagedResultRequest: PagedAndFilteredInputDto): Observable<PagedResultDtoOfWechatUserOutput> {
        let url_ = this.baseUrl + "/api/services/app/WechatUser/Query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pagedResultRequest);

        let options_ : any = {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processQuery(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processQuery(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWechatUserOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfWechatUserOutput>><any>Observable.throw(response_);
        });
    }

    protected processQuery(response: Response): Observable<PagedResultDtoOfWechatUserOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWechatUserOutput.fromJS(resultData200) : new PagedResultDtoOfWechatUserOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PagedResultDtoOfWechatUserOutput>(<any>null);
    }

    /**
     * @return Success
     */
    get(id: number): Observable<WechatUserOutput> {
        let url_ = this.baseUrl + "/api/services/app/WechatUser/Get?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGet(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WechatUserOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<WechatUserOutput>><any>Observable.throw(response_);
        });
    }

    protected processGet(response: Response): Observable<WechatUserOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WechatUserOutput.fromJS(resultData200) : new WechatUserOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<WechatUserOutput>(<any>null);
    }

    /**
     * @openId (optional) 
     * @return Success
     */
    getByOpenId(openId: string): Observable<WechatUserOutput> {
        let url_ = this.baseUrl + "/api/services/app/WechatUser/GetByOpenId?";
        if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetByOpenId(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetByOpenId(<any>response_);
                } catch (e) {
                    return <Observable<WechatUserOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<WechatUserOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetByOpenId(response: Response): Observable<WechatUserOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WechatUserOutput.fromJS(resultData200) : new WechatUserOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<WechatUserOutput>(<any>null);
    }

    /**
     * @subscribeOpenId (optional) 
     * @return Success
     */
    getBySubscribeOpenId(subscribeOpenId: string): Observable<WechatUserOutput> {
        let url_ = this.baseUrl + "/api/services/app/WechatUser/GetBySubscribeOpenId?";
        if (subscribeOpenId !== undefined)
            url_ += "subscribeOpenId=" + encodeURIComponent("" + subscribeOpenId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetBySubscribeOpenId(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetBySubscribeOpenId(<any>response_);
                } catch (e) {
                    return <Observable<WechatUserOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<WechatUserOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetBySubscribeOpenId(response: Response): Observable<WechatUserOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WechatUserOutput.fromJS(resultData200) : new WechatUserOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<WechatUserOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updatePlatformAgreement(input: PlatformAgreementInput): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatUser/UpdatePlatformAgreement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            method: "put",
            headers: new Headers({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processUpdatePlatformAgreement(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processUpdatePlatformAgreement(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdatePlatformAgreement(response: Response): Observable<void> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            return Observable.of<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPlatformAgreement(): Observable<PlatformAgreementOutput> {
        let url_ = this.baseUrl + "/api/services/app/WechatUser/GetPlatformAgreement";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request(url_, options_).flatMap((response_ : any) => {
            return this.processGetPlatformAgreement(response_);
        }).catch((response_: any) => {
            if (response_ instanceof Response) {
                try {
                    return this.processGetPlatformAgreement(<any>response_);
                } catch (e) {
                    return <Observable<PlatformAgreementOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<PlatformAgreementOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetPlatformAgreement(response: Response): Observable<PlatformAgreementOutput> {
        const status = response.status;

        let _headers: any = response.headers ? response.headers.toJSON() : {};
        if (status === 200) {
            const _responseText = response.text();
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PlatformAgreementOutput.fromJS(resultData200) : new PlatformAgreementOutput();
            return Observable.of(result200);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.text();
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Observable.of<PlatformAgreementOutput>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState;
    tenantId: number;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState;
    tenantId: number;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class CategoryOutput implements ICategoryOutput {
    name: string;
    icon: string;
    backgroundColor: string;
    order: number;
    id: number;

    constructor(data?: ICategoryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.icon = data["icon"];
            this.backgroundColor = data["backgroundColor"];
            this.order = data["order"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CategoryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["backgroundColor"] = this.backgroundColor;
        data["order"] = this.order;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CategoryOutput();
        result.init(json);
        return result;
    }
}

export interface ICategoryOutput {
    name: string;
    icon: string;
    backgroundColor: string;
    order: number;
    id: number;
}

export class CategoryCreateInput implements ICategoryCreateInput {
    name: string;
    icon: string;
    backgroundColor: string;
    order: number;

    constructor(data?: ICategoryCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.icon = data["icon"];
            this.backgroundColor = data["backgroundColor"];
            this.order = data["order"];
        }
    }

    static fromJS(data: any): CategoryCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["backgroundColor"] = this.backgroundColor;
        data["order"] = this.order;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CategoryCreateInput();
        result.init(json);
        return result;
    }
}

export interface ICategoryCreateInput {
    name: string;
    icon: string;
    backgroundColor: string;
    order: number;
}

export class CategoryUpdateInput implements ICategoryUpdateInput {
    name: string;
    icon: string;
    backgroundColor: string;
    order: number;
    id: number;

    constructor(data?: ICategoryUpdateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.icon = data["icon"];
            this.backgroundColor = data["backgroundColor"];
            this.order = data["order"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CategoryUpdateInput {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryUpdateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["backgroundColor"] = this.backgroundColor;
        data["order"] = this.order;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CategoryUpdateInput();
        result.init(json);
        return result;
    }
}

export interface ICategoryUpdateInput {
    name: string;
    icon: string;
    backgroundColor: string;
    order: number;
    id: number;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class MobileCategoryOutput implements IMobileCategoryOutput {
    name: string;
    icon: string;
    backgroundColor: string;
    order: number;
    id: number;

    constructor(data?: IMobileCategoryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.icon = data["icon"];
            this.backgroundColor = data["backgroundColor"];
            this.order = data["order"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MobileCategoryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileCategoryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["backgroundColor"] = this.backgroundColor;
        data["order"] = this.order;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileCategoryOutput();
        result.init(json);
        return result;
    }
}

export interface IMobileCategoryOutput {
    name: string;
    icon: string;
    backgroundColor: string;
    order: number;
    id: number;
}

export class PagedResultDtoOfMobileOrderOutput implements IPagedResultDtoOfMobileOrderOutput {
    totalCount: number;
    items: MobileOrderOutput[];

    constructor(data?: IPagedResultDtoOfMobileOrderOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(MobileOrderOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMobileOrderOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMobileOrderOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfMobileOrderOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfMobileOrderOutput {
    totalCount: number;
    items: MobileOrderOutput[];
}

export class MobileOrderOutput implements IMobileOrderOutput {
    serviceProvider: MobileOrderDetailServiceProviderOutput;
    contacts: string;
    tel: string;
    address: string;
    latitude: number;
    longitude: number;
    planTime: moment.Moment;
    serviceItemsData: string;
    remark: string;
    createTime: moment.Moment;
    isReceive: boolean;
    receiveTime: moment.Moment;
    isFinish: boolean;
    finishTime: moment.Moment;
    id: number;

    constructor(data?: IMobileOrderOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serviceProvider = data["serviceProvider"] ? MobileOrderDetailServiceProviderOutput.fromJS(data["serviceProvider"]) : <any>undefined;
            this.contacts = data["contacts"];
            this.tel = data["tel"];
            this.address = data["address"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.planTime = data["planTime"] ? moment(data["planTime"].toString()) : <any>undefined;
            this.serviceItemsData = data["serviceItemsData"];
            this.remark = data["remark"];
            this.createTime = data["createTime"] ? moment(data["createTime"].toString()) : <any>undefined;
            this.isReceive = data["isReceive"];
            this.receiveTime = data["receiveTime"] ? moment(data["receiveTime"].toString()) : <any>undefined;
            this.isFinish = data["isFinish"];
            this.finishTime = data["finishTime"] ? moment(data["finishTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MobileOrderOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileOrderOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceProvider"] = this.serviceProvider ? this.serviceProvider.toJSON() : <any>undefined;
        data["contacts"] = this.contacts;
        data["tel"] = this.tel;
        data["address"] = this.address;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["planTime"] = this.planTime ? this.planTime.toISOString() : <any>undefined;
        data["serviceItemsData"] = this.serviceItemsData;
        data["remark"] = this.remark;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["isReceive"] = this.isReceive;
        data["receiveTime"] = this.receiveTime ? this.receiveTime.toISOString() : <any>undefined;
        data["isFinish"] = this.isFinish;
        data["finishTime"] = this.finishTime ? this.finishTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileOrderOutput();
        result.init(json);
        return result;
    }
}

export interface IMobileOrderOutput {
    serviceProvider: MobileOrderDetailServiceProviderOutput;
    contacts: string;
    tel: string;
    address: string;
    latitude: number;
    longitude: number;
    planTime: moment.Moment;
    serviceItemsData: string;
    remark: string;
    createTime: moment.Moment;
    isReceive: boolean;
    receiveTime: moment.Moment;
    isFinish: boolean;
    finishTime: moment.Moment;
    id: number;
}

export class MobileOrderDetailServiceProviderOutput implements IMobileOrderDetailServiceProviderOutput {
    name: string;
    logo: string;
    level: number;
    detailAddress: string;
    latitude: number;
    longitude: number;
    tel: string;
    about: string;
    serviceItemsData: string;
    isAudited: boolean;
    isDisplay: boolean;
    id: number;

    constructor(data?: IMobileOrderDetailServiceProviderOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.logo = data["logo"];
            this.level = data["level"];
            this.detailAddress = data["detailAddress"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.tel = data["tel"];
            this.about = data["about"];
            this.serviceItemsData = data["serviceItemsData"];
            this.isAudited = data["isAudited"];
            this.isDisplay = data["isDisplay"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MobileOrderDetailServiceProviderOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileOrderDetailServiceProviderOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["logo"] = this.logo;
        data["level"] = this.level;
        data["detailAddress"] = this.detailAddress;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["tel"] = this.tel;
        data["about"] = this.about;
        data["serviceItemsData"] = this.serviceItemsData;
        data["isAudited"] = this.isAudited;
        data["isDisplay"] = this.isDisplay;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileOrderDetailServiceProviderOutput();
        result.init(json);
        return result;
    }
}

export interface IMobileOrderDetailServiceProviderOutput {
    name: string;
    logo: string;
    level: number;
    detailAddress: string;
    latitude: number;
    longitude: number;
    tel: string;
    about: string;
    serviceItemsData: string;
    isAudited: boolean;
    isDisplay: boolean;
    id: number;
}

export class MobileOrderCreateInput implements IMobileOrderCreateInput {
    serviceProviderId: number;
    contacts: string;
    tel: string;
    address: string;
    latitude: number;
    longitude: number;
    planTime: moment.Moment;
    serviceItemsData: string;
    remark: string;
    weappFormId: string;

    constructor(data?: IMobileOrderCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serviceProviderId = data["serviceProviderId"];
            this.contacts = data["contacts"];
            this.tel = data["tel"];
            this.address = data["address"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.planTime = data["planTime"] ? moment(data["planTime"].toString()) : <any>undefined;
            this.serviceItemsData = data["serviceItemsData"];
            this.remark = data["remark"];
            this.weappFormId = data["weappFormId"];
        }
    }

    static fromJS(data: any): MobileOrderCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileOrderCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceProviderId"] = this.serviceProviderId;
        data["contacts"] = this.contacts;
        data["tel"] = this.tel;
        data["address"] = this.address;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["planTime"] = this.planTime ? this.planTime.toISOString() : <any>undefined;
        data["serviceItemsData"] = this.serviceItemsData;
        data["remark"] = this.remark;
        data["weappFormId"] = this.weappFormId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileOrderCreateInput();
        result.init(json);
        return result;
    }
}

export interface IMobileOrderCreateInput {
    serviceProviderId: number;
    contacts: string;
    tel: string;
    address: string;
    latitude: number;
    longitude: number;
    planTime: moment.Moment;
    serviceItemsData: string;
    remark: string;
    weappFormId: string;
}

export class MobileServiceProviderOutput implements IMobileServiceProviderOutput {
    name: string;
    logo: string;
    level: number;
    detailAddress: string;
    latitude: number;
    longitude: number;
    tel: string;
    about: string;
    serviceItemsData: string;
    isAudited: boolean;
    isDisplay: boolean;
    categories: MobileCategoryOutput[];
    companyCertificate: string;
    expirationDate: moment.Moment;
    isExpiration: boolean;
    createTime: moment.Moment;
    updateInfoTime: moment.Moment;
    id: number;

    constructor(data?: IMobileServiceProviderOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.logo = data["logo"];
            this.level = data["level"];
            this.detailAddress = data["detailAddress"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.tel = data["tel"];
            this.about = data["about"];
            this.serviceItemsData = data["serviceItemsData"];
            this.isAudited = data["isAudited"];
            this.isDisplay = data["isDisplay"];
            if (data["categories"] && data["categories"].constructor === Array) {
                this.categories = [];
                for (let item of data["categories"])
                    this.categories.push(MobileCategoryOutput.fromJS(item));
            }
            this.companyCertificate = data["companyCertificate"];
            this.expirationDate = data["expirationDate"] ? moment(data["expirationDate"].toString()) : <any>undefined;
            this.isExpiration = data["isExpiration"];
            this.createTime = data["createTime"] ? moment(data["createTime"].toString()) : <any>undefined;
            this.updateInfoTime = data["updateInfoTime"] ? moment(data["updateInfoTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MobileServiceProviderOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileServiceProviderOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["logo"] = this.logo;
        data["level"] = this.level;
        data["detailAddress"] = this.detailAddress;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["tel"] = this.tel;
        data["about"] = this.about;
        data["serviceItemsData"] = this.serviceItemsData;
        data["isAudited"] = this.isAudited;
        data["isDisplay"] = this.isDisplay;
        if (this.categories && this.categories.constructor === Array) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        data["companyCertificate"] = this.companyCertificate;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["isExpiration"] = this.isExpiration;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateInfoTime"] = this.updateInfoTime ? this.updateInfoTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileServiceProviderOutput();
        result.init(json);
        return result;
    }
}

export interface IMobileServiceProviderOutput {
    name: string;
    logo: string;
    level: number;
    detailAddress: string;
    latitude: number;
    longitude: number;
    tel: string;
    about: string;
    serviceItemsData: string;
    isAudited: boolean;
    isDisplay: boolean;
    categories: MobileCategoryOutput[];
    companyCertificate: string;
    expirationDate: moment.Moment;
    isExpiration: boolean;
    createTime: moment.Moment;
    updateInfoTime: moment.Moment;
    id: number;
}

export class MobileServiceProviderListQueryInput implements IMobileServiceProviderListQueryInput {
    categoryId: number;
    userLatitude: number;
    userLongitude: number;
    maxResultCount: number;
    skipCount: number;
    filter: string;

    constructor(data?: IMobileServiceProviderListQueryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.categoryId = data["categoryId"];
            this.userLatitude = data["userLatitude"];
            this.userLongitude = data["userLongitude"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): MobileServiceProviderListQueryInput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileServiceProviderListQueryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["userLatitude"] = this.userLatitude;
        data["userLongitude"] = this.userLongitude;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileServiceProviderListQueryInput();
        result.init(json);
        return result;
    }
}

export interface IMobileServiceProviderListQueryInput {
    categoryId: number;
    userLatitude: number;
    userLongitude: number;
    maxResultCount: number;
    skipCount: number;
    filter: string;
}

export class PagedResultDtoOfMobileServiceProviderListOutput implements IPagedResultDtoOfMobileServiceProviderListOutput {
    totalCount: number;
    items: MobileServiceProviderListOutput[];

    constructor(data?: IPagedResultDtoOfMobileServiceProviderListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(MobileServiceProviderListOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMobileServiceProviderListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMobileServiceProviderListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfMobileServiceProviderListOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfMobileServiceProviderListOutput {
    totalCount: number;
    items: MobileServiceProviderListOutput[];
}

export class MobileServiceProviderListOutput implements IMobileServiceProviderListOutput {
    name: string;
    logo: string;
    level: number;
    detailAddress: string;
    latitude: number;
    longitude: number;
    id: number;

    constructor(data?: IMobileServiceProviderListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.logo = data["logo"];
            this.level = data["level"];
            this.detailAddress = data["detailAddress"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MobileServiceProviderListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileServiceProviderListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["logo"] = this.logo;
        data["level"] = this.level;
        data["detailAddress"] = this.detailAddress;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileServiceProviderListOutput();
        result.init(json);
        return result;
    }
}

export interface IMobileServiceProviderListOutput {
    name: string;
    logo: string;
    level: number;
    detailAddress: string;
    latitude: number;
    longitude: number;
    id: number;
}

export class MobileServiceProviderDetailOutput implements IMobileServiceProviderDetailOutput {
    expirationPaymentMoney: number;
    ownerWechatUserId: number;
    state: MobileServiceProviderDetailOutputState;
    stateReason: string;
    companyName: string;
    creditCode: string;
    legalPersonName: string;
    legalPersonCertificateNumber: string;
    companyCertificate: string;
    legalPersonFrontCertificate: string;
    name: string;
    logo: string;
    level: number;
    detailAddress: string;
    latitude: number;
    longitude: number;
    tel: string;
    about: string;
    serviceItemsData: string;
    isAudited: boolean;
    isDisplay: boolean;
    categories: MobileCategoryOutput[];
    expirationDate: moment.Moment;
    isExpiration: boolean;
    createTime: moment.Moment;
    updateInfoTime: moment.Moment;
    id: number;

    constructor(data?: IMobileServiceProviderDetailOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.expirationPaymentMoney = data["expirationPaymentMoney"];
            this.ownerWechatUserId = data["ownerWechatUserId"];
            this.state = data["state"];
            this.stateReason = data["stateReason"];
            this.companyName = data["companyName"];
            this.creditCode = data["creditCode"];
            this.legalPersonName = data["legalPersonName"];
            this.legalPersonCertificateNumber = data["legalPersonCertificateNumber"];
            this.companyCertificate = data["companyCertificate"];
            this.legalPersonFrontCertificate = data["legalPersonFrontCertificate"];
            this.name = data["name"];
            this.logo = data["logo"];
            this.level = data["level"];
            this.detailAddress = data["detailAddress"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.tel = data["tel"];
            this.about = data["about"];
            this.serviceItemsData = data["serviceItemsData"];
            this.isAudited = data["isAudited"];
            this.isDisplay = data["isDisplay"];
            if (data["categories"] && data["categories"].constructor === Array) {
                this.categories = [];
                for (let item of data["categories"])
                    this.categories.push(MobileCategoryOutput.fromJS(item));
            }
            this.expirationDate = data["expirationDate"] ? moment(data["expirationDate"].toString()) : <any>undefined;
            this.isExpiration = data["isExpiration"];
            this.createTime = data["createTime"] ? moment(data["createTime"].toString()) : <any>undefined;
            this.updateInfoTime = data["updateInfoTime"] ? moment(data["updateInfoTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MobileServiceProviderDetailOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileServiceProviderDetailOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expirationPaymentMoney"] = this.expirationPaymentMoney;
        data["ownerWechatUserId"] = this.ownerWechatUserId;
        data["state"] = this.state;
        data["stateReason"] = this.stateReason;
        data["companyName"] = this.companyName;
        data["creditCode"] = this.creditCode;
        data["legalPersonName"] = this.legalPersonName;
        data["legalPersonCertificateNumber"] = this.legalPersonCertificateNumber;
        data["companyCertificate"] = this.companyCertificate;
        data["legalPersonFrontCertificate"] = this.legalPersonFrontCertificate;
        data["name"] = this.name;
        data["logo"] = this.logo;
        data["level"] = this.level;
        data["detailAddress"] = this.detailAddress;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["tel"] = this.tel;
        data["about"] = this.about;
        data["serviceItemsData"] = this.serviceItemsData;
        data["isAudited"] = this.isAudited;
        data["isDisplay"] = this.isDisplay;
        if (this.categories && this.categories.constructor === Array) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["isExpiration"] = this.isExpiration;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateInfoTime"] = this.updateInfoTime ? this.updateInfoTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileServiceProviderDetailOutput();
        result.init(json);
        return result;
    }
}

export interface IMobileServiceProviderDetailOutput {
    expirationPaymentMoney: number;
    ownerWechatUserId: number;
    state: MobileServiceProviderDetailOutputState;
    stateReason: string;
    companyName: string;
    creditCode: string;
    legalPersonName: string;
    legalPersonCertificateNumber: string;
    companyCertificate: string;
    legalPersonFrontCertificate: string;
    name: string;
    logo: string;
    level: number;
    detailAddress: string;
    latitude: number;
    longitude: number;
    tel: string;
    about: string;
    serviceItemsData: string;
    isAudited: boolean;
    isDisplay: boolean;
    categories: MobileCategoryOutput[];
    expirationDate: moment.Moment;
    isExpiration: boolean;
    createTime: moment.Moment;
    updateInfoTime: moment.Moment;
    id: number;
}

export class MobileServiceProviderPaymentInfoOutput implements IMobileServiceProviderPaymentInfoOutput {
    paymentedNewExpirationDate: moment.Moment;
    expirationPaymentMoney: number;
    ownerWechatUserId: number;
    state: MobileServiceProviderPaymentInfoOutputState;
    stateReason: string;
    companyName: string;
    creditCode: string;
    legalPersonName: string;
    legalPersonCertificateNumber: string;
    companyCertificate: string;
    legalPersonFrontCertificate: string;
    name: string;
    logo: string;
    level: number;
    detailAddress: string;
    latitude: number;
    longitude: number;
    tel: string;
    about: string;
    serviceItemsData: string;
    isAudited: boolean;
    isDisplay: boolean;
    categories: MobileCategoryOutput[];
    expirationDate: moment.Moment;
    isExpiration: boolean;
    createTime: moment.Moment;
    updateInfoTime: moment.Moment;
    id: number;

    constructor(data?: IMobileServiceProviderPaymentInfoOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentedNewExpirationDate = data["paymentedNewExpirationDate"] ? moment(data["paymentedNewExpirationDate"].toString()) : <any>undefined;
            this.expirationPaymentMoney = data["expirationPaymentMoney"];
            this.ownerWechatUserId = data["ownerWechatUserId"];
            this.state = data["state"];
            this.stateReason = data["stateReason"];
            this.companyName = data["companyName"];
            this.creditCode = data["creditCode"];
            this.legalPersonName = data["legalPersonName"];
            this.legalPersonCertificateNumber = data["legalPersonCertificateNumber"];
            this.companyCertificate = data["companyCertificate"];
            this.legalPersonFrontCertificate = data["legalPersonFrontCertificate"];
            this.name = data["name"];
            this.logo = data["logo"];
            this.level = data["level"];
            this.detailAddress = data["detailAddress"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.tel = data["tel"];
            this.about = data["about"];
            this.serviceItemsData = data["serviceItemsData"];
            this.isAudited = data["isAudited"];
            this.isDisplay = data["isDisplay"];
            if (data["categories"] && data["categories"].constructor === Array) {
                this.categories = [];
                for (let item of data["categories"])
                    this.categories.push(MobileCategoryOutput.fromJS(item));
            }
            this.expirationDate = data["expirationDate"] ? moment(data["expirationDate"].toString()) : <any>undefined;
            this.isExpiration = data["isExpiration"];
            this.createTime = data["createTime"] ? moment(data["createTime"].toString()) : <any>undefined;
            this.updateInfoTime = data["updateInfoTime"] ? moment(data["updateInfoTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MobileServiceProviderPaymentInfoOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileServiceProviderPaymentInfoOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentedNewExpirationDate"] = this.paymentedNewExpirationDate ? this.paymentedNewExpirationDate.toISOString() : <any>undefined;
        data["expirationPaymentMoney"] = this.expirationPaymentMoney;
        data["ownerWechatUserId"] = this.ownerWechatUserId;
        data["state"] = this.state;
        data["stateReason"] = this.stateReason;
        data["companyName"] = this.companyName;
        data["creditCode"] = this.creditCode;
        data["legalPersonName"] = this.legalPersonName;
        data["legalPersonCertificateNumber"] = this.legalPersonCertificateNumber;
        data["companyCertificate"] = this.companyCertificate;
        data["legalPersonFrontCertificate"] = this.legalPersonFrontCertificate;
        data["name"] = this.name;
        data["logo"] = this.logo;
        data["level"] = this.level;
        data["detailAddress"] = this.detailAddress;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["tel"] = this.tel;
        data["about"] = this.about;
        data["serviceItemsData"] = this.serviceItemsData;
        data["isAudited"] = this.isAudited;
        data["isDisplay"] = this.isDisplay;
        if (this.categories && this.categories.constructor === Array) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["isExpiration"] = this.isExpiration;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateInfoTime"] = this.updateInfoTime ? this.updateInfoTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileServiceProviderPaymentInfoOutput();
        result.init(json);
        return result;
    }
}

export interface IMobileServiceProviderPaymentInfoOutput {
    paymentedNewExpirationDate: moment.Moment;
    expirationPaymentMoney: number;
    ownerWechatUserId: number;
    state: MobileServiceProviderPaymentInfoOutputState;
    stateReason: string;
    companyName: string;
    creditCode: string;
    legalPersonName: string;
    legalPersonCertificateNumber: string;
    companyCertificate: string;
    legalPersonFrontCertificate: string;
    name: string;
    logo: string;
    level: number;
    detailAddress: string;
    latitude: number;
    longitude: number;
    tel: string;
    about: string;
    serviceItemsData: string;
    isAudited: boolean;
    isDisplay: boolean;
    categories: MobileCategoryOutput[];
    expirationDate: moment.Moment;
    isExpiration: boolean;
    createTime: moment.Moment;
    updateInfoTime: moment.Moment;
    id: number;
}

export class MobileServiceProviderRegisterInput implements IMobileServiceProviderRegisterInput {
    id: number;
    name: string;
    logo: string;
    detailAddress: string;
    latitude: number;
    longitude: number;
    tel: string;
    about: string;
    companyName: string;
    creditCode: string;
    legalPersonName: string;
    legalPersonCertificateNumber: string;
    companyCertificate: string;
    legalPersonFrontCertificate: string;
    registerFormId: string;

    constructor(data?: IMobileServiceProviderRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.logo = data["logo"];
            this.detailAddress = data["detailAddress"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.tel = data["tel"];
            this.about = data["about"];
            this.companyName = data["companyName"];
            this.creditCode = data["creditCode"];
            this.legalPersonName = data["legalPersonName"];
            this.legalPersonCertificateNumber = data["legalPersonCertificateNumber"];
            this.companyCertificate = data["companyCertificate"];
            this.legalPersonFrontCertificate = data["legalPersonFrontCertificate"];
            this.registerFormId = data["registerFormId"];
        }
    }

    static fromJS(data: any): MobileServiceProviderRegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileServiceProviderRegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["logo"] = this.logo;
        data["detailAddress"] = this.detailAddress;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["tel"] = this.tel;
        data["about"] = this.about;
        data["companyName"] = this.companyName;
        data["creditCode"] = this.creditCode;
        data["legalPersonName"] = this.legalPersonName;
        data["legalPersonCertificateNumber"] = this.legalPersonCertificateNumber;
        data["companyCertificate"] = this.companyCertificate;
        data["legalPersonFrontCertificate"] = this.legalPersonFrontCertificate;
        data["registerFormId"] = this.registerFormId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileServiceProviderRegisterInput();
        result.init(json);
        return result;
    }
}

export interface IMobileServiceProviderRegisterInput {
    id: number;
    name: string;
    logo: string;
    detailAddress: string;
    latitude: number;
    longitude: number;
    tel: string;
    about: string;
    companyName: string;
    creditCode: string;
    legalPersonName: string;
    legalPersonCertificateNumber: string;
    companyCertificate: string;
    legalPersonFrontCertificate: string;
    registerFormId: string;
}

export class EntityDto implements IEntityDto {
    id: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new EntityDto();
        result.init(json);
        return result;
    }
}

export interface IEntityDto {
    id: number;
}

export class MobileServiceProviderUpdateInput implements IMobileServiceProviderUpdateInput {
    name: string;
    logo: string;
    detailAddress: string;
    latitude: number;
    longitude: number;
    tel: string;
    about: string;
    id: number;

    constructor(data?: IMobileServiceProviderUpdateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.logo = data["logo"];
            this.detailAddress = data["detailAddress"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.tel = data["tel"];
            this.about = data["about"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MobileServiceProviderUpdateInput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileServiceProviderUpdateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["logo"] = this.logo;
        data["detailAddress"] = this.detailAddress;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["tel"] = this.tel;
        data["about"] = this.about;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileServiceProviderUpdateInput();
        result.init(json);
        return result;
    }
}

export interface IMobileServiceProviderUpdateInput {
    name: string;
    logo: string;
    detailAddress: string;
    latitude: number;
    longitude: number;
    tel: string;
    about: string;
    id: number;
}

export class MobileServiceProviderItemOutput implements IMobileServiceProviderItemOutput {
    name: string;
    price: number;

    constructor(data?: IMobileServiceProviderItemOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.price = data["price"];
        }
    }

    static fromJS(data: any): MobileServiceProviderItemOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileServiceProviderItemOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["price"] = this.price;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileServiceProviderItemOutput();
        result.init(json);
        return result;
    }
}

export interface IMobileServiceProviderItemOutput {
    name: string;
    price: number;
}

export class MobileServiceProviderItemsUpdateInput implements IMobileServiceProviderItemsUpdateInput {
    serviceItemsData: string;
    id: number;

    constructor(data?: IMobileServiceProviderItemsUpdateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serviceItemsData = data["serviceItemsData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MobileServiceProviderItemsUpdateInput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileServiceProviderItemsUpdateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serviceItemsData"] = this.serviceItemsData;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileServiceProviderItemsUpdateInput();
        result.init(json);
        return result;
    }
}

export interface IMobileServiceProviderItemsUpdateInput {
    serviceItemsData: string;
    id: number;
}

export class PagedResultDtoOfMobileServiceProviderOrderOutput implements IPagedResultDtoOfMobileServiceProviderOrderOutput {
    totalCount: number;
    items: MobileServiceProviderOrderOutput[];

    constructor(data?: IPagedResultDtoOfMobileServiceProviderOrderOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(MobileServiceProviderOrderOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMobileServiceProviderOrderOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMobileServiceProviderOrderOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfMobileServiceProviderOrderOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfMobileServiceProviderOrderOutput {
    totalCount: number;
    items: MobileServiceProviderOrderOutput[];
}

export class MobileServiceProviderOrderOutput implements IMobileServiceProviderOrderOutput {
    wechatUser: MobileWechatUserOutput;
    receiveWechatUser: MobileWechatUserOutput;
    serviceProvider: MobileOrderDetailServiceProviderOutput;
    contacts: string;
    tel: string;
    address: string;
    latitude: number;
    longitude: number;
    planTime: moment.Moment;
    serviceItemsData: string;
    remark: string;
    createTime: moment.Moment;
    isReceive: boolean;
    receiveTime: moment.Moment;
    isFinish: boolean;
    finishTime: moment.Moment;
    id: number;

    constructor(data?: IMobileServiceProviderOrderOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wechatUser = data["wechatUser"] ? MobileWechatUserOutput.fromJS(data["wechatUser"]) : <any>undefined;
            this.receiveWechatUser = data["receiveWechatUser"] ? MobileWechatUserOutput.fromJS(data["receiveWechatUser"]) : <any>undefined;
            this.serviceProvider = data["serviceProvider"] ? MobileOrderDetailServiceProviderOutput.fromJS(data["serviceProvider"]) : <any>undefined;
            this.contacts = data["contacts"];
            this.tel = data["tel"];
            this.address = data["address"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.planTime = data["planTime"] ? moment(data["planTime"].toString()) : <any>undefined;
            this.serviceItemsData = data["serviceItemsData"];
            this.remark = data["remark"];
            this.createTime = data["createTime"] ? moment(data["createTime"].toString()) : <any>undefined;
            this.isReceive = data["isReceive"];
            this.receiveTime = data["receiveTime"] ? moment(data["receiveTime"].toString()) : <any>undefined;
            this.isFinish = data["isFinish"];
            this.finishTime = data["finishTime"] ? moment(data["finishTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MobileServiceProviderOrderOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileServiceProviderOrderOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wechatUser"] = this.wechatUser ? this.wechatUser.toJSON() : <any>undefined;
        data["receiveWechatUser"] = this.receiveWechatUser ? this.receiveWechatUser.toJSON() : <any>undefined;
        data["serviceProvider"] = this.serviceProvider ? this.serviceProvider.toJSON() : <any>undefined;
        data["contacts"] = this.contacts;
        data["tel"] = this.tel;
        data["address"] = this.address;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["planTime"] = this.planTime ? this.planTime.toISOString() : <any>undefined;
        data["serviceItemsData"] = this.serviceItemsData;
        data["remark"] = this.remark;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["isReceive"] = this.isReceive;
        data["receiveTime"] = this.receiveTime ? this.receiveTime.toISOString() : <any>undefined;
        data["isFinish"] = this.isFinish;
        data["finishTime"] = this.finishTime ? this.finishTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileServiceProviderOrderOutput();
        result.init(json);
        return result;
    }
}

export interface IMobileServiceProviderOrderOutput {
    wechatUser: MobileWechatUserOutput;
    receiveWechatUser: MobileWechatUserOutput;
    serviceProvider: MobileOrderDetailServiceProviderOutput;
    contacts: string;
    tel: string;
    address: string;
    latitude: number;
    longitude: number;
    planTime: moment.Moment;
    serviceItemsData: string;
    remark: string;
    createTime: moment.Moment;
    isReceive: boolean;
    receiveTime: moment.Moment;
    isFinish: boolean;
    finishTime: moment.Moment;
    id: number;
}

export class MobileWechatUserOutput implements IMobileWechatUserOutput {
    nickname: string;
    avatarUrl: string;
    gender: number;
    country: string;
    province: string;
    city: string;
    id: number;

    constructor(data?: IMobileWechatUserOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.nickname = data["nickname"];
            this.avatarUrl = data["avatarUrl"];
            this.gender = data["gender"];
            this.country = data["country"];
            this.province = data["province"];
            this.city = data["city"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MobileWechatUserOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileWechatUserOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nickname"] = this.nickname;
        data["avatarUrl"] = this.avatarUrl;
        data["gender"] = this.gender;
        data["country"] = this.country;
        data["province"] = this.province;
        data["city"] = this.city;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileWechatUserOutput();
        result.init(json);
        return result;
    }
}

export interface IMobileWechatUserOutput {
    nickname: string;
    avatarUrl: string;
    gender: number;
    country: string;
    province: string;
    city: string;
    id: number;
}

export class BannerAdOutput implements IBannerAdOutput {
    image: string;
    url: string;
    id: number;

    constructor(data?: IBannerAdOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.image = data["image"];
            this.url = data["url"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BannerAdOutput {
        data = typeof data === 'object' ? data : {};
        let result = new BannerAdOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["image"] = this.image;
        data["url"] = this.url;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new BannerAdOutput();
        result.init(json);
        return result;
    }
}

export interface IBannerAdOutput {
    image: string;
    url: string;
    id: number;
}

export class MobileServiceProviderPaymentRecordOutput implements IMobileServiceProviderPaymentRecordOutput {
    money: number;
    oldExpirationDate: moment.Moment;
    currentExpirationDate: moment.Moment;
    newExpirationDate: moment.Moment;
    prepayID: string;
    isPayed: boolean;
    payedDateTime: moment.Moment;
    isRefund: boolean;
    refundID: string;
    refundTime: moment.Moment;
    createTime: moment.Moment;
    id: number;

    constructor(data?: IMobileServiceProviderPaymentRecordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.money = data["money"];
            this.oldExpirationDate = data["oldExpirationDate"] ? moment(data["oldExpirationDate"].toString()) : <any>undefined;
            this.currentExpirationDate = data["currentExpirationDate"] ? moment(data["currentExpirationDate"].toString()) : <any>undefined;
            this.newExpirationDate = data["newExpirationDate"] ? moment(data["newExpirationDate"].toString()) : <any>undefined;
            this.prepayID = data["prepayID"];
            this.isPayed = data["isPayed"];
            this.payedDateTime = data["payedDateTime"] ? moment(data["payedDateTime"].toString()) : <any>undefined;
            this.isRefund = data["isRefund"];
            this.refundID = data["refundID"];
            this.refundTime = data["refundTime"] ? moment(data["refundTime"].toString()) : <any>undefined;
            this.createTime = data["createTime"] ? moment(data["createTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MobileServiceProviderPaymentRecordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileServiceProviderPaymentRecordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["money"] = this.money;
        data["oldExpirationDate"] = this.oldExpirationDate ? this.oldExpirationDate.toISOString() : <any>undefined;
        data["currentExpirationDate"] = this.currentExpirationDate ? this.currentExpirationDate.toISOString() : <any>undefined;
        data["newExpirationDate"] = this.newExpirationDate ? this.newExpirationDate.toISOString() : <any>undefined;
        data["prepayID"] = this.prepayID;
        data["isPayed"] = this.isPayed;
        data["payedDateTime"] = this.payedDateTime ? this.payedDateTime.toISOString() : <any>undefined;
        data["isRefund"] = this.isRefund;
        data["refundID"] = this.refundID;
        data["refundTime"] = this.refundTime ? this.refundTime.toISOString() : <any>undefined;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileServiceProviderPaymentRecordOutput();
        result.init(json);
        return result;
    }
}

export interface IMobileServiceProviderPaymentRecordOutput {
    money: number;
    oldExpirationDate: moment.Moment;
    currentExpirationDate: moment.Moment;
    newExpirationDate: moment.Moment;
    prepayID: string;
    isPayed: boolean;
    payedDateTime: moment.Moment;
    isRefund: boolean;
    refundID: string;
    refundTime: moment.Moment;
    createTime: moment.Moment;
    id: number;
}

export class WechatUserOutput implements IWechatUserOutput {
    nickname: string;
    avatarUrl: string;
    gender: number;
    country: string;
    province: string;
    city: string;
    createTime: moment.Moment;
    updateInfoTime: moment.Moment;
    subscribeOpenId: string;
    isBindSubscribe: boolean;
    id: number;

    constructor(data?: IWechatUserOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.nickname = data["nickname"];
            this.avatarUrl = data["avatarUrl"];
            this.gender = data["gender"];
            this.country = data["country"];
            this.province = data["province"];
            this.city = data["city"];
            this.createTime = data["createTime"] ? moment(data["createTime"].toString()) : <any>undefined;
            this.updateInfoTime = data["updateInfoTime"] ? moment(data["updateInfoTime"].toString()) : <any>undefined;
            this.subscribeOpenId = data["subscribeOpenId"];
            this.isBindSubscribe = data["isBindSubscribe"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WechatUserOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WechatUserOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nickname"] = this.nickname;
        data["avatarUrl"] = this.avatarUrl;
        data["gender"] = this.gender;
        data["country"] = this.country;
        data["province"] = this.province;
        data["city"] = this.city;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateInfoTime"] = this.updateInfoTime ? this.updateInfoTime.toISOString() : <any>undefined;
        data["subscribeOpenId"] = this.subscribeOpenId;
        data["isBindSubscribe"] = this.isBindSubscribe;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new WechatUserOutput();
        result.init(json);
        return result;
    }
}

export interface IWechatUserOutput {
    nickname: string;
    avatarUrl: string;
    gender: number;
    country: string;
    province: string;
    city: string;
    createTime: moment.Moment;
    updateInfoTime: moment.Moment;
    subscribeOpenId: string;
    isBindSubscribe: boolean;
    id: number;
}

export class MobileBindSubscribeInput implements IMobileBindSubscribeInput {
    encryptedData: string;

    constructor(data?: IMobileBindSubscribeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.encryptedData = data["encryptedData"];
        }
    }

    static fromJS(data: any): MobileBindSubscribeInput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileBindSubscribeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["encryptedData"] = this.encryptedData;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileBindSubscribeInput();
        result.init(json);
        return result;
    }
}

export interface IMobileBindSubscribeInput {
    encryptedData: string;
}

export class MobileWechatUserAddressOutput implements IMobileWechatUserAddressOutput {
    contacts: string;
    tel: string;
    address: string;
    latitude: number;
    longitude: number;
    isDefault: boolean;
    id: number;

    constructor(data?: IMobileWechatUserAddressOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contacts = data["contacts"];
            this.tel = data["tel"];
            this.address = data["address"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.isDefault = data["isDefault"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MobileWechatUserAddressOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileWechatUserAddressOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contacts"] = this.contacts;
        data["tel"] = this.tel;
        data["address"] = this.address;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["isDefault"] = this.isDefault;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileWechatUserAddressOutput();
        result.init(json);
        return result;
    }
}

export interface IMobileWechatUserAddressOutput {
    contacts: string;
    tel: string;
    address: string;
    latitude: number;
    longitude: number;
    isDefault: boolean;
    id: number;
}

export class MobileWechatUserAddressCreateOrUpdateInput implements IMobileWechatUserAddressCreateOrUpdateInput {
    id: number;
    contacts: string;
    tel: string;
    address: string;
    latitude: number;
    longitude: number;

    constructor(data?: IMobileWechatUserAddressCreateOrUpdateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contacts = data["contacts"];
            this.tel = data["tel"];
            this.address = data["address"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
        }
    }

    static fromJS(data: any): MobileWechatUserAddressCreateOrUpdateInput {
        data = typeof data === 'object' ? data : {};
        let result = new MobileWechatUserAddressCreateOrUpdateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contacts"] = this.contacts;
        data["tel"] = this.tel;
        data["address"] = this.address;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new MobileWechatUserAddressCreateOrUpdateInput();
        result.init(json);
        return result;
    }
}

export interface IMobileWechatUserAddressCreateOrUpdateInput {
    id: number;
    contacts: string;
    tel: string;
    address: string;
    latitude: number;
    longitude: number;
}

export class PagedResultDtoOfOrderOutput implements IPagedResultDtoOfOrderOutput {
    totalCount: number;
    items: OrderOutput[];

    constructor(data?: IPagedResultDtoOfOrderOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrderOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrderOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrderOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfOrderOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfOrderOutput {
    totalCount: number;
    items: OrderOutput[];
}

export class OrderOutput implements IOrderOutput {
    wechatUser: MobileWechatUserOutput;
    contacts: string;
    tel: string;
    address: string;
    latitude: number;
    longitude: number;
    planTime: moment.Moment;
    serviceItemsData: string;
    remark: string;
    createTime: moment.Moment;
    isReceive: boolean;
    receiveTime: moment.Moment;
    isFinish: boolean;
    finishTime: moment.Moment;
    id: number;

    constructor(data?: IOrderOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wechatUser = data["wechatUser"] ? MobileWechatUserOutput.fromJS(data["wechatUser"]) : <any>undefined;
            this.contacts = data["contacts"];
            this.tel = data["tel"];
            this.address = data["address"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.planTime = data["planTime"] ? moment(data["planTime"].toString()) : <any>undefined;
            this.serviceItemsData = data["serviceItemsData"];
            this.remark = data["remark"];
            this.createTime = data["createTime"] ? moment(data["createTime"].toString()) : <any>undefined;
            this.isReceive = data["isReceive"];
            this.receiveTime = data["receiveTime"] ? moment(data["receiveTime"].toString()) : <any>undefined;
            this.isFinish = data["isFinish"];
            this.finishTime = data["finishTime"] ? moment(data["finishTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrderOutput {
        data = typeof data === 'object' ? data : {};
        let result = new OrderOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wechatUser"] = this.wechatUser ? this.wechatUser.toJSON() : <any>undefined;
        data["contacts"] = this.contacts;
        data["tel"] = this.tel;
        data["address"] = this.address;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["planTime"] = this.planTime ? this.planTime.toISOString() : <any>undefined;
        data["serviceItemsData"] = this.serviceItemsData;
        data["remark"] = this.remark;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["isReceive"] = this.isReceive;
        data["receiveTime"] = this.receiveTime ? this.receiveTime.toISOString() : <any>undefined;
        data["isFinish"] = this.isFinish;
        data["finishTime"] = this.finishTime ? this.finishTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new OrderOutput();
        result.init(json);
        return result;
    }
}

export interface IOrderOutput {
    wechatUser: MobileWechatUserOutput;
    contacts: string;
    tel: string;
    address: string;
    latitude: number;
    longitude: number;
    planTime: moment.Moment;
    serviceItemsData: string;
    remark: string;
    createTime: moment.Moment;
    isReceive: boolean;
    receiveTime: moment.Moment;
    isFinish: boolean;
    finishTime: moment.Moment;
    id: number;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string;
    description: string;
    isStatic: boolean;
    permissions: string[];

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            this.isStatic = data["isStatic"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string;
    description: string;
    isStatic: boolean;
    permissions: string[];
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string;
    description: string;
    isStatic: boolean;
    permissions: string[];
    id: number;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            this.isStatic = data["isStatic"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string;
    description: string;
    isStatic: boolean;
    permissions: string[];
    id: number;
}

export class ListResultDtoOfPermissionDto implements IListResultDtoOfPermissionDto {
    items: PermissionDto[];

    constructor(data?: IListResultDtoOfPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ListResultDtoOfPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfPermissionDto {
    items: PermissionDto[];
}

export class PermissionDto implements IPermissionDto {
    name: string;
    displayName: string;
    description: string;
    id: number;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string;
    displayName: string;
    description: string;
    id: number;
}

export class PagedResultDtoOfRoleDto implements IPagedResultDtoOfRoleDto {
    totalCount: number;
    items: RoleDto[];

    constructor(data?: IPagedResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRoleDto {
    totalCount: number;
    items: RoleDto[];
}

export class ServiceProviderOutput implements IServiceProviderOutput {
    name: string;
    logo: string;
    level: number;
    detailAddress: string;
    latitude: number;
    longitude: number;
    tel: string;
    about: string;
    serviceItemsData: string;
    isAudited: boolean;
    isDisplay: boolean;
    ownerWechatUser: WechatUserOutput;
    categories: CategoryOutput[];
    state: ServiceProviderOutputState;
    stateReason: string;
    expirationPaymentMoney: number;
    expirationDate: moment.Moment;
    isExpiration: boolean;
    companyName: string;
    creditCode: string;
    legalPersonName: string;
    legalPersonCertificateNumber: string;
    companyCertificate: string;
    legalPersonFrontCertificate: string;
    createTime: moment.Moment;
    updateInfoTime: moment.Moment;
    id: number;

    constructor(data?: IServiceProviderOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.logo = data["logo"];
            this.level = data["level"];
            this.detailAddress = data["detailAddress"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.tel = data["tel"];
            this.about = data["about"];
            this.serviceItemsData = data["serviceItemsData"];
            this.isAudited = data["isAudited"];
            this.isDisplay = data["isDisplay"];
            this.ownerWechatUser = data["ownerWechatUser"] ? WechatUserOutput.fromJS(data["ownerWechatUser"]) : <any>undefined;
            if (data["categories"] && data["categories"].constructor === Array) {
                this.categories = [];
                for (let item of data["categories"])
                    this.categories.push(CategoryOutput.fromJS(item));
            }
            this.state = data["state"];
            this.stateReason = data["stateReason"];
            this.expirationPaymentMoney = data["expirationPaymentMoney"];
            this.expirationDate = data["expirationDate"] ? moment(data["expirationDate"].toString()) : <any>undefined;
            this.isExpiration = data["isExpiration"];
            this.companyName = data["companyName"];
            this.creditCode = data["creditCode"];
            this.legalPersonName = data["legalPersonName"];
            this.legalPersonCertificateNumber = data["legalPersonCertificateNumber"];
            this.companyCertificate = data["companyCertificate"];
            this.legalPersonFrontCertificate = data["legalPersonFrontCertificate"];
            this.createTime = data["createTime"] ? moment(data["createTime"].toString()) : <any>undefined;
            this.updateInfoTime = data["updateInfoTime"] ? moment(data["updateInfoTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ServiceProviderOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["logo"] = this.logo;
        data["level"] = this.level;
        data["detailAddress"] = this.detailAddress;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["tel"] = this.tel;
        data["about"] = this.about;
        data["serviceItemsData"] = this.serviceItemsData;
        data["isAudited"] = this.isAudited;
        data["isDisplay"] = this.isDisplay;
        data["ownerWechatUser"] = this.ownerWechatUser ? this.ownerWechatUser.toJSON() : <any>undefined;
        if (this.categories && this.categories.constructor === Array) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        data["state"] = this.state;
        data["stateReason"] = this.stateReason;
        data["expirationPaymentMoney"] = this.expirationPaymentMoney;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["isExpiration"] = this.isExpiration;
        data["companyName"] = this.companyName;
        data["creditCode"] = this.creditCode;
        data["legalPersonName"] = this.legalPersonName;
        data["legalPersonCertificateNumber"] = this.legalPersonCertificateNumber;
        data["companyCertificate"] = this.companyCertificate;
        data["legalPersonFrontCertificate"] = this.legalPersonFrontCertificate;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateInfoTime"] = this.updateInfoTime ? this.updateInfoTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ServiceProviderOutput();
        result.init(json);
        return result;
    }
}

export interface IServiceProviderOutput {
    name: string;
    logo: string;
    level: number;
    detailAddress: string;
    latitude: number;
    longitude: number;
    tel: string;
    about: string;
    serviceItemsData: string;
    isAudited: boolean;
    isDisplay: boolean;
    ownerWechatUser: WechatUserOutput;
    categories: CategoryOutput[];
    state: ServiceProviderOutputState;
    stateReason: string;
    expirationPaymentMoney: number;
    expirationDate: moment.Moment;
    isExpiration: boolean;
    companyName: string;
    creditCode: string;
    legalPersonName: string;
    legalPersonCertificateNumber: string;
    companyCertificate: string;
    legalPersonFrontCertificate: string;
    createTime: moment.Moment;
    updateInfoTime: moment.Moment;
    id: number;
}

export class PagedResultDtoOfServiceProviderListOutput implements IPagedResultDtoOfServiceProviderListOutput {
    totalCount: number;
    items: ServiceProviderListOutput[];

    constructor(data?: IPagedResultDtoOfServiceProviderListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ServiceProviderListOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfServiceProviderListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfServiceProviderListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfServiceProviderListOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfServiceProviderListOutput {
    totalCount: number;
    items: ServiceProviderListOutput[];
}

export class ServiceProviderListOutput implements IServiceProviderListOutput {
    name: string;
    logo: string;
    level: number;
    detailAddress: string;
    latitude: number;
    longitude: number;
    isAudited: boolean;
    isDisplay: boolean;
    state: ServiceProviderListOutputState;
    expirationDate: moment.Moment;
    isExpiration: boolean;
    expirationPaymentMoney: number;
    companyName: string;
    legalPersonName: string;
    id: number;

    constructor(data?: IServiceProviderListOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.logo = data["logo"];
            this.level = data["level"];
            this.detailAddress = data["detailAddress"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.isAudited = data["isAudited"];
            this.isDisplay = data["isDisplay"];
            this.state = data["state"];
            this.expirationDate = data["expirationDate"] ? moment(data["expirationDate"].toString()) : <any>undefined;
            this.isExpiration = data["isExpiration"];
            this.expirationPaymentMoney = data["expirationPaymentMoney"];
            this.companyName = data["companyName"];
            this.legalPersonName = data["legalPersonName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ServiceProviderListOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderListOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["logo"] = this.logo;
        data["level"] = this.level;
        data["detailAddress"] = this.detailAddress;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["isAudited"] = this.isAudited;
        data["isDisplay"] = this.isDisplay;
        data["state"] = this.state;
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["isExpiration"] = this.isExpiration;
        data["expirationPaymentMoney"] = this.expirationPaymentMoney;
        data["companyName"] = this.companyName;
        data["legalPersonName"] = this.legalPersonName;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ServiceProviderListOutput();
        result.init(json);
        return result;
    }
}

export interface IServiceProviderListOutput {
    name: string;
    logo: string;
    level: number;
    detailAddress: string;
    latitude: number;
    longitude: number;
    isAudited: boolean;
    isDisplay: boolean;
    state: ServiceProviderListOutputState;
    expirationDate: moment.Moment;
    isExpiration: boolean;
    expirationPaymentMoney: number;
    companyName: string;
    legalPersonName: string;
    id: number;
}

export class ServiceProviderUpdateInput implements IServiceProviderUpdateInput {
    name: string;
    logo: string;
    detailAddress: string;
    latitude: number;
    longitude: number;
    tel: string;
    about: string;
    companyName: string;
    creditCode: string;
    legalPersonName: string;
    legalPersonCertificateNumber: string;
    companyCertificate: string;
    legalPersonFrontCertificate: string;
    id: number;

    constructor(data?: IServiceProviderUpdateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.logo = data["logo"];
            this.detailAddress = data["detailAddress"];
            this.latitude = data["latitude"];
            this.longitude = data["longitude"];
            this.tel = data["tel"];
            this.about = data["about"];
            this.companyName = data["companyName"];
            this.creditCode = data["creditCode"];
            this.legalPersonName = data["legalPersonName"];
            this.legalPersonCertificateNumber = data["legalPersonCertificateNumber"];
            this.companyCertificate = data["companyCertificate"];
            this.legalPersonFrontCertificate = data["legalPersonFrontCertificate"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ServiceProviderUpdateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderUpdateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["logo"] = this.logo;
        data["detailAddress"] = this.detailAddress;
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        data["tel"] = this.tel;
        data["about"] = this.about;
        data["companyName"] = this.companyName;
        data["creditCode"] = this.creditCode;
        data["legalPersonName"] = this.legalPersonName;
        data["legalPersonCertificateNumber"] = this.legalPersonCertificateNumber;
        data["companyCertificate"] = this.companyCertificate;
        data["legalPersonFrontCertificate"] = this.legalPersonFrontCertificate;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ServiceProviderUpdateInput();
        result.init(json);
        return result;
    }
}

export interface IServiceProviderUpdateInput {
    name: string;
    logo: string;
    detailAddress: string;
    latitude: number;
    longitude: number;
    tel: string;
    about: string;
    companyName: string;
    creditCode: string;
    legalPersonName: string;
    legalPersonCertificateNumber: string;
    companyCertificate: string;
    legalPersonFrontCertificate: string;
    id: number;
}

export class ServiceProviderUpdateDisplayStateInput implements IServiceProviderUpdateDisplayStateInput {
    isDisplay: boolean;
    id: number;

    constructor(data?: IServiceProviderUpdateDisplayStateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isDisplay = data["isDisplay"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ServiceProviderUpdateDisplayStateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderUpdateDisplayStateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDisplay"] = this.isDisplay;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ServiceProviderUpdateDisplayStateInput();
        result.init(json);
        return result;
    }
}

export interface IServiceProviderUpdateDisplayStateInput {
    isDisplay: boolean;
    id: number;
}

export class ServiceProviderUpdateAuditStateInput implements IServiceProviderUpdateAuditStateInput {
    isAudited: boolean;
    stateReason: string;
    id: number;

    constructor(data?: IServiceProviderUpdateAuditStateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isAudited = data["isAudited"];
            this.stateReason = data["stateReason"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ServiceProviderUpdateAuditStateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderUpdateAuditStateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isAudited"] = this.isAudited;
        data["stateReason"] = this.stateReason;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ServiceProviderUpdateAuditStateInput();
        result.init(json);
        return result;
    }
}

export interface IServiceProviderUpdateAuditStateInput {
    isAudited: boolean;
    stateReason: string;
    id: number;
}

export class ServiceProviderUpdateCategoriesInput implements IServiceProviderUpdateCategoriesInput {
    categoryIdList: number[];
    id: number;

    constructor(data?: IServiceProviderUpdateCategoriesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["categoryIdList"] && data["categoryIdList"].constructor === Array) {
                this.categoryIdList = [];
                for (let item of data["categoryIdList"])
                    this.categoryIdList.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ServiceProviderUpdateCategoriesInput {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderUpdateCategoriesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.categoryIdList && this.categoryIdList.constructor === Array) {
            data["categoryIdList"] = [];
            for (let item of this.categoryIdList)
                data["categoryIdList"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ServiceProviderUpdateCategoriesInput();
        result.init(json);
        return result;
    }
}

export interface IServiceProviderUpdateCategoriesInput {
    categoryIdList: number[];
    id: number;
}

export class ServiceProviderUpdateExpirationDateInput implements IServiceProviderUpdateExpirationDateInput {
    expirationDate: moment.Moment;
    id: number;

    constructor(data?: IServiceProviderUpdateExpirationDateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.expirationDate = data["expirationDate"] ? moment(data["expirationDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ServiceProviderUpdateExpirationDateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderUpdateExpirationDateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expirationDate"] = this.expirationDate ? this.expirationDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ServiceProviderUpdateExpirationDateInput();
        result.init(json);
        return result;
    }
}

export interface IServiceProviderUpdateExpirationDateInput {
    expirationDate: moment.Moment;
    id: number;
}

export class ServiceProviderUpdateExpirationPaymentMoneyInput implements IServiceProviderUpdateExpirationPaymentMoneyInput {
    expirationPaymentMoney: number;
    id: number;

    constructor(data?: IServiceProviderUpdateExpirationPaymentMoneyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.expirationPaymentMoney = data["expirationPaymentMoney"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ServiceProviderUpdateExpirationPaymentMoneyInput {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderUpdateExpirationPaymentMoneyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expirationPaymentMoney"] = this.expirationPaymentMoney;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ServiceProviderUpdateExpirationPaymentMoneyInput();
        result.init(json);
        return result;
    }
}

export interface IServiceProviderUpdateExpirationPaymentMoneyInput {
    expirationPaymentMoney: number;
    id: number;
}

export class ServiceProviderItemOutput implements IServiceProviderItemOutput {
    name: string;
    price: number;
    order: number;
    id: number;

    constructor(data?: IServiceProviderItemOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.price = data["price"];
            this.order = data["order"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ServiceProviderItemOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderItemOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["price"] = this.price;
        data["order"] = this.order;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ServiceProviderItemOutput();
        result.init(json);
        return result;
    }
}

export interface IServiceProviderItemOutput {
    name: string;
    price: number;
    order: number;
    id: number;
}

export class ServiceProviderItemCreateInput implements IServiceProviderItemCreateInput {
    name: string;
    price: number;
    order: number;

    constructor(data?: IServiceProviderItemCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.price = data["price"];
            this.order = data["order"];
        }
    }

    static fromJS(data: any): ServiceProviderItemCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderItemCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["price"] = this.price;
        data["order"] = this.order;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ServiceProviderItemCreateInput();
        result.init(json);
        return result;
    }
}

export interface IServiceProviderItemCreateInput {
    name: string;
    price: number;
    order: number;
}

export class ServiceProviderItemUpdateInput implements IServiceProviderItemUpdateInput {
    name: string;
    price: number;
    order: number;
    id: number;

    constructor(data?: IServiceProviderItemUpdateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.price = data["price"];
            this.order = data["order"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ServiceProviderItemUpdateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ServiceProviderItemUpdateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["price"] = this.price;
        data["order"] = this.order;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ServiceProviderItemUpdateInput();
        result.init(json);
        return result;
    }
}

export interface IServiceProviderItemUpdateInput {
    name: string;
    price: number;
    order: number;
    id: number;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string;
    releaseDate: moment.Moment;
    features: { [key: string] : boolean; };

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string;
    releaseDate: moment.Moment;
    features: { [key: string] : boolean; };
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    id: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string;
    name: string;
    id: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string;
    name: string;
    id: number;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string;
    isActive: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string;
    isActive: boolean;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean;
    id: number;
}

export class PagedResultDtoOfTenantDto implements IPagedResultDtoOfTenantDto {
    totalCount: number;
    items: TenantDto[];

    constructor(data?: IPagedResultDtoOfTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTenantDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTenantDto {
    totalCount: number;
    items: TenantDto[];
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.rememberClient = data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string;
    encryptedAccessToken: string;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string;
    encryptedAccessToken: string;
    expireInSeconds: number;
    userId: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string;
    clientId: string;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string;
    clientId: string;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string;
    encryptedAccessToken: string;
    expireInSeconds: number;
    waitingForActivation: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string;
    encryptedAccessToken: string;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[];
    password: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[];
    password: string;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string;
    lastLoginTime: moment.Moment;
    creationTime: moment.Moment;
    roleNames: string[];
    id: number;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.fullName = data["fullName"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string;
    lastLoginTime: moment.Moment;
    creationTime: moment.Moment;
    roleNames: string[];
    id: number;
}

export class ListResultDtoOfRoleDto implements IListResultDtoOfRoleDto {
    items: RoleDto[];

    constructor(data?: IListResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleDto {
    items: RoleDto[];
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class PagedResultDtoOfUserDto implements IPagedResultDtoOfUserDto {
    totalCount: number;
    items: UserDto[];

    constructor(data?: IPagedResultDtoOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserDto {
    totalCount: number;
    items: UserDto[];
}

export class WeappAuthenticateModel implements IWeappAuthenticateModel {
    code: string;
    encryptedData: string;
    iv: string;

    constructor(data?: IWeappAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.encryptedData = data["encryptedData"];
            this.iv = data["iv"];
        }
    }

    static fromJS(data: any): WeappAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new WeappAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["encryptedData"] = this.encryptedData;
        data["iv"] = this.iv;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new WeappAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IWeappAuthenticateModel {
    code: string;
    encryptedData: string;
    iv: string;
}

export class WeappAuthenticateResultModel implements IWeappAuthenticateResultModel {
    accessToken: string;
    encryptedAccessToken: string;
    expireInSeconds: number;
    wechatUser: WechatUserOutput;

    constructor(data?: IWeappAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.wechatUser = data["wechatUser"] ? WechatUserOutput.fromJS(data["wechatUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WeappAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new WeappAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["wechatUser"] = this.wechatUser ? this.wechatUser.toJSON() : <any>undefined;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new WeappAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IWeappAuthenticateResultModel {
    accessToken: string;
    encryptedAccessToken: string;
    expireInSeconds: number;
    wechatUser: WechatUserOutput;
}

export class WechatUserCreateOrUpdateInput implements IWechatUserCreateOrUpdateInput {
    openId: string;
    unionId: string;
    nickname: string;
    avatarUrl: string;
    gender: number;
    country: string;
    province: string;
    city: string;

    constructor(data?: IWechatUserCreateOrUpdateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.openId = data["openId"];
            this.unionId = data["unionId"];
            this.nickname = data["nickname"];
            this.avatarUrl = data["avatarUrl"];
            this.gender = data["gender"];
            this.country = data["country"];
            this.province = data["province"];
            this.city = data["city"];
        }
    }

    static fromJS(data: any): WechatUserCreateOrUpdateInput {
        data = typeof data === 'object' ? data : {};
        let result = new WechatUserCreateOrUpdateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["openId"] = this.openId;
        data["unionId"] = this.unionId;
        data["nickname"] = this.nickname;
        data["avatarUrl"] = this.avatarUrl;
        data["gender"] = this.gender;
        data["country"] = this.country;
        data["province"] = this.province;
        data["city"] = this.city;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new WechatUserCreateOrUpdateInput();
        result.init(json);
        return result;
    }
}

export interface IWechatUserCreateOrUpdateInput {
    openId: string;
    unionId: string;
    nickname: string;
    avatarUrl: string;
    gender: number;
    country: string;
    province: string;
    city: string;
}

export class PagedAndFilteredInputDto implements IPagedAndFilteredInputDto {
    maxResultCount: number;
    skipCount: number;
    filter: string;

    constructor(data?: IPagedAndFilteredInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): PagedAndFilteredInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedAndFilteredInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedAndFilteredInputDto();
        result.init(json);
        return result;
    }
}

export interface IPagedAndFilteredInputDto {
    maxResultCount: number;
    skipCount: number;
    filter: string;
}

export class PagedResultDtoOfWechatUserOutput implements IPagedResultDtoOfWechatUserOutput {
    totalCount: number;
    items: WechatUserOutput[];

    constructor(data?: IPagedResultDtoOfWechatUserOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(WechatUserOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWechatUserOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWechatUserOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PagedResultDtoOfWechatUserOutput();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfWechatUserOutput {
    totalCount: number;
    items: WechatUserOutput[];
}

export class PlatformAgreementInput implements IPlatformAgreementInput {
    content: string;

    constructor(data?: IPlatformAgreementInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
        }
    }

    static fromJS(data: any): PlatformAgreementInput {
        data = typeof data === 'object' ? data : {};
        let result = new PlatformAgreementInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PlatformAgreementInput();
        result.init(json);
        return result;
    }
}

export interface IPlatformAgreementInput {
    content: string;
}

export class PlatformAgreementOutput implements IPlatformAgreementOutput {
    content: string;

    constructor(data?: IPlatformAgreementOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.content = data["content"];
        }
    }

    static fromJS(data: any): PlatformAgreementOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PlatformAgreementOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        return data; 
    }

    clone() {
        const json = this.toJSON();
        let result = new PlatformAgreementOutput();
        result.init(json);
        return result;
    }
}

export interface IPlatformAgreementOutput {
    content: string;
}

export enum IsTenantAvailableOutputState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum MobileServiceProviderDetailOutputState {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum MobileServiceProviderPaymentInfoOutputState {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum ServiceProviderOutputState {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum ServiceProviderListOutputState {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}